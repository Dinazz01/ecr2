############################################
# Data sources (safe to keep even if unused)
############################################
data "aws_caller_identity" "current" {}
data "aws_partition" "current" {}

############################################
# Optional: only created when we actually
# need to generate a new signer profile name
############################################
resource "random_string" "signer_suffix" {
  count   = var.enable_signing && var.signing_profile_arn == null && var.signing_profile_name == null ? 1 : 0
  length  = 6
  special = false
  upper   = false
}

############################################
# Locals (toggle logic + robust fallbacks)
############################################
locals {
  # Core AWS facts
  account_id = data.aws_caller_identity.current.account_id
  partition  = data.aws_partition.current.partition
  arn_prefix = "arn:${local.partition}:iam::${local.account_id}"

  # Repo toggles
  create_private_repository = var.create && var.create_repository && var.repository_type == "private"
  create_public_repository  = var.create && var.create_repository && var.repository_type == "public"

  # Clean env/name → repo name (ECR allows [a-z0-9/_-]; keep it simple w/ a-z0-9-)
  env_token   = coalesce(var.env_abbr, var.environment, "env")
  raw_repo    = "${lower(replace(local.env_token,     "/[^a-z0-9-]/", "-"))}-${lower(replace(var.name, "/[^a-z0-9-]/", "-"))}"
  repository_name = substr(local.raw_repo, 0, 255) # guard length

  # Whether to encrypt the repo (default true) and which key to use (optional)
  enable_encryption = coalesce(var.enable_encryption, true)
  kms_key_arn       = var.kms_key_arn # pass through when you bring-your-own key

  # IAM role ARNs (avoid hardcoding account id)
  repository_role_arn    = var.repository_role_name    != null ? "${local.arn_prefix}:role/${var.repository_role_name}"    : null
  default_node_role_arn  = var.default_node_role_name  != null ? "${local.arn_prefix}:role/${var.default_node_role_name}"  : "${local.arn_prefix}:role/role-${var.environment}-AmazonEKSNodeRole"
  default_iam_role_arn   = var.default_iam_role_name   != null ? "${local.arn_prefix}:role/${var.default_iam_role_name}"   : "${local.arn_prefix}:role/role-${var.environment}-AmazonNodeGroupRole"

  # ---- AWS Signer (won't crash if it already exists) ----
  # If you provide signing_profile_arn, we will NOT try to create one.
  # If you provide signing_profile_name, we will use that name (and you can create the resource conditionally).
  # Otherwise we generate a valid, <=64-char name with a random suffix.
  signer_enabled          = coalesce(var.enable_signing, false)
  signer_suffix           = try(random_string.signer_suffix[0].result, "")
  generated_signer_name   = substr(
                              lower(replace("ecr-container-signing-${local.env_token}-${var.name}-${local.signer_suffix}", "/[^a-z0-9-]/", "-")),
                              0,
                              64
                            )
  signing_profile_name    = coalesce(var.signing_profile_name, local.generated_signer_name)
  create_signing_profile  = local.signer_enabled && var.signing_profile_arn == null

  # Use the provided ARN if given; otherwise the resource you create can fill it in.
  # (Example: set this to aws_signer_signing_profile.this[0].arn where you declare it.)
  effective_signing_profile_arn = coalesce(
    var.signing_profile_arn,
    null
  )
}
============================================================================================================
#Minimal variables these locals expect
#(Use exactly what you need; all have safe defaults or can be null.)

variable "create"                 { type = bool   default = true }
variable "create_repository"      { type = bool   default = true }
variable "repository_type"        { type = string default = "private" } # "private" | "public"

variable "environment"            { type = string }
variable "env_abbr"               { type = string default = null }
variable "name"                   { type = string } # base repo/app name

variable "enable_encryption"      { type = bool   default = true }
variable "kms_key_arn"            { type = string default = null }

variable "repository_role_name"   { type = string default = null } # e.g. "ecr-repo-access-role"
variable "default_node_role_name" { type = string default = null } # override if your EKS role name differs
variable "default_iam_role_name"  { type = string default = null } # override if your nodegroup role name differs

# Signer toggles
variable "enable_signing"         { type = bool   default = false }
variable "signing_profile_arn"    { type = string default = null }  # if you already have one, set this and skip creation
variable "signing_profile_name"   { type = string default = null }  # to force a specific name when creating
================================================================================================================
#How to wire Signer so it never crashes
#If you want Terraform to create the profile only when one isn’t supplied:

resource "aws_signer_signing_profile" "this" {
  count = local.create_signing_profile ? 1 : 0

  name = local.signing_profile_name
  platform_id = "AWSLambda-SHA384-ECDSA" # or "AWSIoTDevice-SHA256" / container platform when supported in your region
}

# Then, wherever you need the ARN:
locals {
  signer_profile_arn = coalesce(
    var.signing_profile_arn,
    try(aws_signer_signing_profile.this[0].arn, null)
  )
}
====================================================================================
====================================================================
1) variables.tf 

variable "create"                 { type = bool   default = true }
variable "create_repository"      { type = bool   default = true }
variable "repository_type"        { type = string default = "private" } # "private" | "public"

variable "environment"            { type = string }
variable "env_abbr"               { type = string default = null }
variable "name"                   { type = string }                     # base repo/app name

# Encryption (KMS is optional)
variable "enable_encryption"      { type = bool   default = true }
variable "kms_key_arn"            { type = string default = null }      # BYO key (skip creation)
variable "create_kms_key"         { type = bool   default = false }     # create a key in this module?

# Optional role names (avoid hardcoding ARNs)
variable "repository_role_name"   { type = string default = null }
variable "default_node_role_name" { type = string default = null }
variable "default_iam_role_name"  { type = string default = null }

# Signer
variable "enable_signing"         { type = bool   default = false }
variable "signing_profile_arn"    { type = string default = null }      # use existing profile
variable "signing_profile_name"   { type = string default = null }      # force specific name if creating

# Repo policy (optional)
variable "create_repository_policy" { type = bool default = false }
variable "repository_read_access_arns" {
  type    = list(string)
  default = []
}

============================================================================================================
2) data + random (top of main.tf)

data "aws_caller_identity" "current" {}
data "aws_partition" "current" {}

resource "random_string" "signer_suffix" {
  count   = var.enable_signing && var.signing_profile_arn == null && var.signing_profile_name == null ? 1 : 0
  length  = 6
  special = false
  upper   = false
}

==============================================================================================================
3) locals (paste/replace your locals block)

locals {
  account_id = data.aws_caller_identity.current.account_id
  partition  = data.aws_partition.current.partition
  arn_prefix = "arn:${local.partition}:iam::${local.account_id}"

  create_private_repository = var.create && var.create_repository && var.repository_type == "private"
  create_public_repository  = var.create && var.create_repository && var.repository_type == "public"

  env_token   = coalesce(var.env_abbr, var.environment, "env")
  raw_repo    = "${lower(replace(local.env_token, "/[^a-z0-9-]/", "-"))}-${lower(replace(var.name, "/[^a-z0-9-]/", "-"))}"
  repository_name = substr(local.raw_repo, 0, 255)

  enable_encryption = coalesce(var.enable_encryption, true)

  repository_role_arn   = var.repository_role_name   != null ? "${local.arn_prefix}:role/${var.repository_role_name}"   : null
  default_node_role_arn = var.default_node_role_name != null ? "${local.arn_prefix}:role/${var.default_node_role_name}" : "${local.arn_prefix}:role/role-${var.environment}-AmazonEKSNodeRole"
  default_iam_role_arn  = var.default_iam_role_name  != null ? "${local.arn_prefix}:role/${var.default_iam_role_name}"  : "${local.arn_prefix}:role/role-${var.environment}-AmazonNodeGroupRole"

  # ----- Signer logic (safe + conditional) -----
  signer_enabled        = coalesce(var.enable_signing, false)
  signer_suffix         = try(random_string.signer_suffix[0].result, "")
  generated_signer_name = substr(
                            lower(replace("ecr-container-signing-${local.env_token}-${var.name}-${local.signer_suffix}", "/[^a-z0-9-]/", "-")),
                            0, 64
                          )
  signing_profile_name   = coalesce(var.signing_profile_name, local.generated_signer_name)
  create_signing_profile = local.signer_enabled && var.signing_profile_arn == null
}

=========================================================================================================================================================

4) optional KMS (only if you want the module to create the key)

resource "aws_kms_key" "this" {
  count                   = var.create_kms_key ? 1 : 0
  description             = "ECR encryption key for ${local.repository_name}"
  enable_key_rotation     = true
  deletion_window_in_days = 7
}

locals {
  effective_kms_key_arn = coalesce(
    var.kms_key_arn,
    try(aws_kms_key.this[0].arn, null)
  )
}
5) Signer (conditional create)
hcl
Copy
Edit
resource "aws_signer_signing_profile" "container" {
  count = local.create_signing_profile ? 1 : 0

  name                 = local.signing_profile_name
  platform_id          = "AWSLambda-SHA384-ECDSA" # keep if this is the platform you’re targeting
  platform_display_name = "AWS Lambda SHA384 ECDSA"

  tags = {
    Name = local.repository_name
  }
}

locals {
  signer_profile_arn = coalesce(
    var.signing_profile_arn,
    try(aws_signer_signing_profile.container[0].arn, null)
  )
}
You can now pass enable_signing = true and either supply signing_profile_arn (no creation) or leave it empty (module creates one with a safe name).
============================================================================================================================
6) ECR repository (scan on push + optional KMS)

resource "aws_ecr_repository" "this" {
  count                = local.create_private_repository ? 1 : 0
  name                 = local.repository_name
  force_delete         = false
  image_tag_mutability = "IMMUTABLE"

  image_scanning_configuration {
    scan_on_push = true
  }

  dynamic "encryption_configuration" {
    for_each = local.enable_encryption && local.effective_kms_key_arn != null ? [1] : []
    content {
      encryption_type = "KMS"
      kms_key         = local.effective_kms_key_arn
    }
  }

  tags = {
    Name        = local.repository_name
    Environment = var.environment
  }
}
7) (Optional) Private repo policy
hcl
Copy
Edit
data "aws_iam_policy_document" "repository" {
  count = local.create_private_repository && var.create_repository_policy ? 1 : 0

  statement {
    sid     = "PrivateReadOnly"
    actions = ["ecr:BatchGetImage", "ecr:GetDownloadUrlForLayer", "ecr:DescribeImages", "ecr:DescribeRepositories"]
    principals {
      type        = "AWS"
      identifiers = length(var.repository_read_access_arns) > 0 ? var.repository_read_access_arns : []
    }
    resources = [aws_ecr_repository.this[0].arn]
  }
}

resource "aws_ecr_repository_policy" "this" {
  count      = local.create_private_repository && var.create_repository_policy ? 1 : 0
  repository = aws_ecr_repository.this[0].name
  policy     = data.aws_iam_policy_document.repository[0].json
}
8) outputs.tf
hcl
Copy
Edit
output "repository_name" {
  value       = try(aws_ecr_repository.this[0].name, null)
  description = "ECR repository name"
}

output "repository_arn" {
  value       = try(aws_ecr_repository.this[0].arn, null)
  description = "ECR repository ARN"
}

output "kms_key_arn" {
  value       = local.effective_kms_key_arn
  description = "KMS key used for repository encryption (if any)"
}

output "signing_profile_arn" {
  value       = local.signer_profile_arn
  description = "AWS Signer profile ARN (existing or created)"
}
==================================================================
9) Example usage

module "ecr" {
  source = "./modules/aws-ecr"

  name         = "myapp"
  environment  = "dev"
  env_abbr     = "d"

  # repo
  create                  = true
  create_repository       = true
  repository_type         = "private"
  create_repository_policy = true
  repository_read_access_arns = [
    "arn:aws:iam::123456789012:role/my-ci-role"
  ]

  # kms: either bring one, or let module create
  enable_encryption = true
  create_kms_key    = true
  # kms_key_arn     = "arn:aws:kms:us-east-1:123456789012:key/...."  # if you bring your own

  # signer:
  enable_signing       = true
  # signing_profile_arn = "arn:aws:signer:us-east-1:123456789012:/signing-profiles/existing" # to reuse
  # signing_profile_name = "custom-profile-name"  # to force name on create

  # optional role names (if you want to reference them elsewhere)
  repository_role_name   = "ecr-repo-access-role"
  default_node_role_name = null
  default_iam_role_name  = null
}


Create a Signer profile only when you haven’t provided an ARN.

Never index a zero-count resource, thanks to try(...).

Encrypt ECR with KMS when enabled (BYO or created).

Always scan on push.

Avoid hardcoded ARNs by composing them from account/partition.
















================






